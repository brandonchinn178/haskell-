%YAML 1.2
---
name: Haskell Syntax
file_extensions: [hs]
scope: source.haskell

variables:
  # Identifiers and Operators
  # https://www.haskell.org/onlinereport/lexemes.html#sect2.4
  lower_ident: '[a-z][\w'']*'
  upper_ident: '[A-Z][\w'']*'
  symbol_char: '[!#$%&*+./<=>?@\^|-~:]'
  operator: '(?!:){{symbol_char}}+'
  operator_con: ':{{symbol_char}}*'

contexts:
  prototype:
    - include: comments

  main:
    - include: module_header
    - include: imports

  ### Identifiers ###

  module_name:
    - match: '({{upper_ident}}\.)*({{upper_ident}})'
      scope: entity.name.namespace.haskell

  ### Utilities ###

  pop_when_deindent:
    - match: '^(?!\1\s)'
      pop: true

  ### Comments ###

  comments:
    - include: pragmas
    - include: comments_line
    - include: comments_block

  comments_line:
    - match: --
      scope: punctuation.definition.comment
      push: comments_line_body

  comments_line_body:
    - meta_include_prototype: false
    - meta_scope: comment.line.haskell
    - match: \n
      pop: true

  pragmas:
    - match: '{-#'
      scope: punctuation.definition.comment
      push: pragmas_body

  pragmas_body:
    - meta_include_prototype: false
    - meta_scope: comment.block.pragma.haskell
    - match: '#-}'
      scope: punctuation.definition.comment
      pop: true
    - match: (?i)ANN
      scope: keyword.other.pragma.haskell
      push: pragmas_annotation
    - match: |-
        (?ix)
            LANGUAGE
          | OPTIONS_GHC
          | INCLUDE
          | WARNING
          | DEPRECATED
          | MINIMAL
          | INLINE
          | NOINLINE
          | INLINABLE
          | CONLIKE
          | LINE
          | COLUMN
          | RULES
          | SPECIALIZE
          | SPECIALICE
          | UNPACK
          | NOUNPACK
          | SOURCE
          | COMPLETE
          | OVERLAPPING
          | OVERLAPPABLE
          | OVERLAPS
          | INCOHERENT
      scope: keyword.other.pragma.haskell

  pragmas_annotation:
    - clear_scopes: true
    - meta_scope: meta.annotation.haskell
    - match: '(?=#-})'
      pop: true
    - match: \b(type|module)\b
      scope: keyword.other.annotation.haskell
    - include: expressions

  comments_block:
    - match: '{-'
      scope: punctuation.definition.comment
      push: comments_block_body

  comments_block_body:
    - meta_include_prototype: false
    - meta_scope: comment.block.haskell
    - match: '{-'
      push: comments_block_body
    - match: '-}'
      scope: punctuation.definition.comment
      pop: true

  ### Module header ##

  module_header:
    - match: ^(\s*)(module)\b
      captures:
        2: keyword.declaration.namespace.haskell
      push: module_header_line

  module_header_line:
    - meta_scope: meta.declaration.module.haskell
    - include: module_name
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: module_header_exports_list
    - match: \b(where)\b
      scope: keyword.control.context.haskell
      pop: true

  module_header_exports_list:
    - meta_scope: meta.declaration.exports.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: \b(type) (\({{operator}}\))
      captures:
        1: keyword.other.export.haskell
        2: keyword.operator.type.haskell
    - match: \b(pattern) ({{upper_ident}})
      captures:
        1: keyword.other.export.haskell
        2: variable.function.pattern.haskell
    - # explicitly check for `(..)`
      match: |-
        (?x)
          (\()
          (\.\.)
          (\))
      scope: meta.export.type_members.haskell
      captures:
        1: punctuation.section.parens.begin.haskell
        2: keyword.operator.export.wildcard.haskell
        3: punctuation.section.parens.end.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: imports_list_type_members
    - match: '{{upper_ident}}'
      scope: storage.type.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell

  ### Imports ###

  imports:
    - match: ^(\s*)(import)\b
      captures:
        2: keyword.control.import.haskell
      push: imports_line

  imports_line:
    - meta_scope: meta.import.haskell
    - include: pop_when_deindent
    - match: \b(qualified|as|hiding)\b
      scope: keyword.control.import.modifiers.haskell
    - include: module_name
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: imports_list

  # import UnliftIO (UnliftIO, withRunInIO)
  #                  ^^^^^^^^^^^^^^^^^^^^^
  imports_list:
    - meta_scope: meta.declaration.imports.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: \b(type) (\({{operator}}\))
      captures:
        1: keyword.other.import.haskell
        2: keyword.operator.type.haskell
    - match: \b(pattern) ({{upper_ident}})
      captures:
        1: keyword.other.import.haskell
        2: variable.function.pattern.haskell
    - # explicitly check for `(..)`
      match: |-
        (?x)
          (\()
          (\.\.)
          (\))
      scope: meta.import.type_members.haskell
      captures:
        1: punctuation.section.parens.begin.haskell
        2: keyword.operator.import.wildcard.haskell
        3: punctuation.section.parens.end.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: imports_list_type_members
    - match: '{{upper_ident}}'
      scope: storage.type.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell

  # import GHC.Exts (IsList (Item, fromList))
  #                          ^^^^^^^^^^^^^^
  imports_list_type_members:
    - meta_scope: meta.import.type_members.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: '{{upper_ident}}'
      scope: variable.function.constructor.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell
    - match: \({{operator_con}}\)
      scope: keyword.operator.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell #variable.other.import.operator.haskell

  ### Expressions ###

  expressions:
    - match: '{{lower_ident}}'
      scope: variable.other.function.haskell
    - match: '{{upper_ident}}'
      scope: variable.other.type.haskell
    - match: '"'
      push: expressions_string_body

  expressions_string_body:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.haskell
    - match: '"'
      pop: true
