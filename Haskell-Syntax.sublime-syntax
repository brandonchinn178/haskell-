%YAML 1.2
---
name: Haskell Syntax
file_extensions: [hs]
scope: source.haskell

variables:
  # Identifiers and Operators
  # https://www.haskell.org/onlinereport/lexemes.html#sect2.4
  lower_ident: '\b[a-z_][\w'']*\b'
  upper_ident: '\b[A-Z][\w'']*\b'
  symbol_char: '[!#$%&*+./<=>?@\\^|\-~:]'
  operator: '(?!:){{symbol_char}}+'
  operator_con: ':{{symbol_char}}*'

contexts:
  prototype:
    - include: comment

  main:
    - include: module_header
    - include: import
    - include: function  # TODO: replace with function_or_toplevel_call

  ### Utilities ###

  pop_when_deindent:
    - match: '^(?!\1\s)'
      pop: true

  ### Comments ###

  comment:
    - include: pragma
    - include: comment_line
    - include: comment_block

  comment_line:
    - match: --
      scope: punctuation.definition.comment
      push: comment_line_body

  comment_line_body:
    - meta_include_prototype: false
    - meta_scope: comment.line.haskell
    - match: \n
      pop: true

  pragma:
    - match: '{-#'
      scope: punctuation.definition.comment
      push: pragma_body

  pragma_body:
    - meta_include_prototype: false
    - meta_scope: comment.block.pragma.haskell
    - match: '#-}'
      scope: punctuation.definition.comment
      pop: true
    - match: (?i)ANN
      scope: keyword.other.pragma.haskell
      push: pragmas_annotation
    - match: |-
        (?ix)
            LANGUAGE
          | OPTIONS_GHC
          | INCLUDE
          | WARNING
          | DEPRECATED
          | MINIMAL
          | INLINE
          | NOINLINE
          | INLINABLE
          | CONLIKE
          | LINE
          | COLUMN
          | RULES
          | SPECIALIZE
          | SPECIALICE
          | UNPACK
          | NOUNPACK
          | SOURCE
          | COMPLETE
          | OVERLAPPING
          | OVERLAPPABLE
          | OVERLAPS
          | INCOHERENT
      scope: keyword.other.pragma.haskell

  pragmas_annotation:
    - clear_scopes: true
    - meta_scope: meta.annotation.haskell
    - match: '(?=#-})'
      pop: true
    - match: \b(type|module)\b
      scope: keyword.other.annotation.haskell
    - include: expression

  comment_block:
    - match: '{-'
      scope: punctuation.definition.comment
      push: comment_block_body

  comment_block_body:
    - meta_include_prototype: false
    - meta_scope: comment.block.haskell
    - match: '{-'
      push: comment_block_body
    - match: '-}'
      scope: punctuation.definition.comment
      pop: true

  ### Module header ##

  module_header:
    - match: ^(\s*)(module)\b
      captures:
        2: keyword.declaration.namespace.haskell
      push: module_header_line

  module_header_line:
    - meta_scope: meta.declaration.module.haskell
    - match: '({{upper_ident}}\.)*({{upper_ident}})'
      scope: entity.name.namespace.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: module_header_exports_list
    - match: \b(where)\b
      scope: keyword.control.context.haskell
      pop: true

  module_header_exports_list:
    - meta_scope: meta.declaration.exports.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: \b(type) (\({{operator}}\))
      captures:
        1: keyword.other.export.haskell
        2: keyword.operator.type.haskell
    - match: \b(pattern) ({{upper_ident}})
      captures:
        1: keyword.other.export.haskell
        2: variable.function.pattern.haskell
    - # explicitly check for `(..)`
      match: |-
        (?x)
          (\()
          (\.\.)
          (\))
      scope: meta.export.type_members.haskell
      captures:
        1: punctuation.section.parens.begin.haskell
        2: keyword.other.wildcard.export.haskell
        3: punctuation.section.parens.end.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: import_list_type_members
    - match: '{{upper_ident}}'
      scope: storage.type.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell

  ### Imports ###

  import:
    - match: ^(\s*)(import)\b
      captures:
        2: keyword.control.import.haskell
      push: import_line

  import_line:
    - meta_scope: meta.import.haskell
    - include: pop_when_deindent
    - match: \b(qualified|as|hiding)\b
      scope: keyword.control.import.modifiers.haskell
    - match: '({{upper_ident}}\.)*({{upper_ident}})'
      scope: storage.module.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: import_list

  # import UnliftIO (UnliftIO, withRunInIO)
  #                  ^^^^^^^^^^^^^^^^^^^^^
  import_list:
    - meta_scope: meta.declaration.imports.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: \b(type) (\({{operator}}\))
      captures:
        1: keyword.other.import.haskell
        2: keyword.operator.type.haskell
    - match: \b(pattern) ({{upper_ident}})
      captures:
        1: keyword.other.import.haskell
        2: variable.function.pattern.haskell
    - # explicitly check for `(..)`
      match: |-
        (?x)
          (\()
          (\.\.)
          (\))
      scope: meta.import.type_members.haskell
      captures:
        1: punctuation.section.parens.begin.haskell
        2: keyword.other.wildcard.import.haskell
        3: punctuation.section.parens.end.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: import_list_type_members
    - match: '{{upper_ident}}'
      scope: storage.type.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell

  # import GHC.Exts (IsList (Item, fromList))
  #                          ^^^^^^^^^^^^^^
  import_list_type_members:
    - meta_scope: meta.import.type_members.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: '{{upper_ident}}'
      scope: variable.function.constructor.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell
    - match: \({{operator_con}}\)
      scope: keyword.operator.constructor.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell #variable.other.import.operator.haskell

  ### Functions ###

  # TODO: uncomment
  # # At the very top-level, a function can be defined or called (a Template
  # # Haskell splice) and we don't know until we see or don't see an equals
  # # sign.
  # #
  # # We'll first try to parse a function call, and if we see an equals sign
  # # we'll abort. Trying this first because:
  # #   * Listing function args should be short, like fewer than 5 lines
  # #   * Sublime Text refuses to backtrack after 128 lines, so if a
  # #     function call goes past 128 lines, it won't backtrack if we try
  # #     parsing it as a function definition first. A function call has
  # #     a much higher chance of being 128+ lines than a function definition
  # #
  # # https://forum.sublimetext.com/t/syntax-branch-help-common-short-vs-rare-long/60863/3
  # # Test the performance with `benchmark_toplevel_funcs`
  # function_or_toplevel_call:
  #   - match: '^(?=\s*{{lower_ident}})'
  #     branch_point: function_or_toplevel_call
  #     branch:
  #       - function_toplevel_call
  #       - function

  function:
    - match: '^(\s*)({{lower_ident}})'
      captures:
        2: entity.name.function.haskell
      branch_point: function
      branch:
        # try signature first, since it's easier to check if it fails
        # (nothing can go between the identifier and the '::')
        - function_signature
        - function_definition

  function_definition:
    - meta_content_scope: |-
        meta.function.parameters.haskell
        meta.pattern.haskell
    - include: pop_when_deindent
    - match: '='
      scope: keyword.other.function.definition.haskell
      set: function_definition_body
    - include: pattern_match

  function_definition_body:
    - include: pop_when_deindent
    - include: expression

  function_signature:
    - match: '\s(::)\s'
      captures:
        1: keyword.other.function.signature.haskell
      set: function_signature_type
    - include: pop_when_deindent
    - match: '\S'
      fail: function

  function_signature_type:
    - include: pop_when_deindent
    # TODO

  # TODO: uncomment
  # function_toplevel_call:
  #   - match: '^(\s*)'
  #     set: expression
  #     with_prototype:
  #       - include: pop_when_deindent
  #       - match: '(?<!{{symbol_char}})=(?!{{symbol_char}})'
  #         fail: function_or_toplevel_call

  ### Expressions ###

  expression:
    - include: expression_numeric
    - match: '"'
      push: expression_string_body
    # TODO: parse let-statements with pattern matching, maybe function definition?
    # TODO: parse case-statements with pattern matching
    - match: |-
        (?x)
          (
              let
            | in
            | case
            | of
            | do
            | if
            | then
            | else
          )
          (?=[^\w'])
      scope: keyword.control.haskell
    - # identifiers that are keywords when certain extensions are enabled
      match: |-
        (?x)
          (
              mdo
            | rec
          )
          (?=[^\w'])
      scope: keyword.control.extension_dependent.haskell
    - match: (error|undefined)(?=[^\w'])
      scope: variable.other.error.haskell
    - match: '({{upper_ident}}\.)*({{lower_ident}})'
      captures:
        1: storage.module.haskell
        2: variable.other.haskell
    - match: '({{upper_ident}}\.)*({{upper_ident}})'
      captures:
        1: storage.module.haskell
        2: variable.function.constructor.haskell
    - match: '''{1,2}{{upper_ident}}'
      scope: variable.other.constructor.haskell
    - match: '`({{upper_ident}}\.)*({{lower_ident}})`'
      scope: variable.other.infix.haskell
    - match: '`({{upper_ident}}\.)*({{upper_ident}})`'
      scope: variable.function.constructor.infix.haskell
    # TODO: parse type annotations
    - match: ':{{symbol_char}}*'
      scope: keyword.operator.constructor.haskell
    - match: '\(:{{symbol_char}}*\)'
      scope: keyword.operator.constructor.prefix.haskell
    - match: '\(,*\)'
      scope: keyword.operator.constructor.prefix.haskell
    - match: '{{symbol_char}}+'
      scope: keyword.operator.haskell
    - match: '\({{symbol_char}}+\)'
      scope: keyword.operator.prefix.haskell
    - include: expression_quasiquote
    - match: '\['
      scope: punctuation.section.list.begin.haskell
      push: expression_list_body
    - # pretend like all parenthetical groups are tuples
      # a non-tuple like `(f x)` can still be thought of
      # as a tuple of one element
      match: '\('
      scope: punctuation.section.tuple.begin.haskell
      push: expression_tuple_body

  expression_string_body:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.haskell
    - match: '"'
      pop: true

  expression_list_body:
    - match: ','
      scope: punctuation.separator.list.haskell
    # TODO: parse list comprehensions, with pattern matching
    - match: '\]'
      scope: punctuation.section.list.end.haskell
      pop: true
    - include: expression

  expression_tuple_body:
    - match: ','
      scope: punctuation.separator.tuple.haskell
    - match: '\)'
      scope: punctuation.section.tuple.end.haskell
      pop: true
    - include: expression

  expression_numeric:
    - match: '((?<=\s)-)?\d+\.\d+(e-?\d+)?'
      scope: constant.numeric.float.haskell
    - match: '((?<=\s)-)?\d+e-?\d+'
      scope: constant.numeric.float.haskell
    - match: '((?<=\s)-)?0[bB][0-1]+'
      scope: constant.numeric.integer.binary.haskell
    - match: '((?<=\s)-)?0[oO][0-7]+'
      scope: constant.numeric.integer.octal.haskell
    - match: '((?<=\s)-)?0[xX][0-9a-f]+'
      scope: constant.numeric.integer.hexadecimal.haskell
    - match: '((?<=\s)-)?\d+'
      scope: constant.numeric.integer.decimal.haskell

  expression_quasiquote:
    - match: '\[e?\|'
      scope: punctuation.section.quasiquote.template_haskell.begin.haskell
      embed: expression
      embed_scope: meta.block.template_haskell.haskell
      escape: '\|\]'
      escape_captures:
        0: punctuation.section.quasiquote.template_haskell.end.haskell
    # TODO: [d|...|]
    # TODO: [t|...|]
    # TODO: [p|...|]
    - match: '\[({{upper_ident}}\.)*{{lower_ident}}\|'
      scope: punctuation.section.quasiquote.begin.haskell
      embed: expression_quasiquote_body
      embed_scope: string.quoted.quasiquote.haskell
      escape: '\|\]'
      escape_captures:
        0: punctuation.section.quasiquote.end.haskell

  expression_quasiquote_body: []

  ### Pattern matching ###

  pattern_match:
    - match: '\b_\b'
      scope: keyword.other.wildcard.haskell
    - match: '{{lower_ident}}'
      scope: variable.other.haskell
    - match: '{{upper_ident}}'
      scope: variable.other.constructor.haskell
    - match: '@'
      scope: keyword.other.as_pattern.haskell
    - match: '\('
      scope: punctuation.section.parens.begin.haskell
    - match: '\)'
      scope: punctuation.section.parens.end.haskell
    - match: '\{'
      scope: punctuation.section.braces.begin.haskell
      push: pattern_match_record
    - match: '{{operator_con}}'
      scope: keyword.operator.constructor.haskell

  pattern_match_record:
    - meta_scope: meta.pattern.record.haskell
    - match: '\}'
      scope: punctuation.section.braces.end.haskell
      pop: true
    - # Person{boss = Just _, ..} (RecordWildCards)
      #                       ^^
      match: \.\.
      scope: keyword.other.wildcard.record.haskell
    - match: ','
      scope: punctuation.separator.haskell
    - # Person{boss = Just Person{name = name}}
      #        ^^^^^^
      match: '({{lower_ident}})\s*(=)'
      captures:
        1: variable.other.member.haskell
        2: keyword.operator.haskell
      push: pattern_match_record_nested
    - # Person{boss} (NamedFieldPuns)
      #        ^^^^
      match: '{{lower_ident}}'
      scope: variable.other.haskell

  # Person{boss = Just Person{name = name}}
  #               ^^^^^^^^^^^^^^^^^^^^^^^^
  pattern_match_record_nested:
    - match: '(?=[,}])'
      pop: true
    - include: pattern_match
