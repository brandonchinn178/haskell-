%YAML 1.2
---
name: Haskell Syntax
file_extensions: [hs]
scope: source.haskell

variables:
  # Identifiers and Operators
  # https://www.haskell.org/onlinereport/lexemes.html#sect2.4
  lower_ident: '\b[a-z_][\w'']*\b'
  upper_ident: '\b[A-Z][\w'']*\b'
  symbol_char: '[!#$%&*+./<=>?@\^|-~:]'
  operator: '(?!:){{symbol_char}}+'
  operator_con: ':{{symbol_char}}*'

contexts:
  prototype:
    - include: comment

  main:
    - include: module_header
    - include: import
    - include: function

  ### Identifiers ###

  module_name:
    - match: '({{upper_ident}}\.)*({{upper_ident}})'
      scope: storage.module.haskell

  ### Utilities ###

  pop_when_deindent:
    - match: '^(?!\1\s)'
      pop: true

  ### Comments ###

  comment:
    - include: pragma
    - include: comment_line
    - include: comment_block

  comment_line:
    - match: --
      scope: punctuation.definition.comment
      push: comment_line_body

  comment_line_body:
    - meta_include_prototype: false
    - meta_scope: comment.line.haskell
    - match: \n
      pop: true

  pragma:
    - match: '{-#'
      scope: punctuation.definition.comment
      push: pragma_body

  pragma_body:
    - meta_include_prototype: false
    - meta_scope: comment.block.pragma.haskell
    - match: '#-}'
      scope: punctuation.definition.comment
      pop: true
    - match: (?i)ANN
      scope: keyword.other.pragma.haskell
      push: pragmas_annotation
    - match: |-
        (?ix)
            LANGUAGE
          | OPTIONS_GHC
          | INCLUDE
          | WARNING
          | DEPRECATED
          | MINIMAL
          | INLINE
          | NOINLINE
          | INLINABLE
          | CONLIKE
          | LINE
          | COLUMN
          | RULES
          | SPECIALIZE
          | SPECIALICE
          | UNPACK
          | NOUNPACK
          | SOURCE
          | COMPLETE
          | OVERLAPPING
          | OVERLAPPABLE
          | OVERLAPS
          | INCOHERENT
      scope: keyword.other.pragma.haskell

  pragmas_annotation:
    - clear_scopes: true
    - meta_scope: meta.annotation.haskell
    - match: '(?=#-})'
      pop: true
    - match: \b(type|module)\b
      scope: keyword.other.annotation.haskell
    - include: expression

  comment_block:
    - match: '{-'
      scope: punctuation.definition.comment
      push: comment_block_body

  comment_block_body:
    - meta_include_prototype: false
    - meta_scope: comment.block.haskell
    - match: '{-'
      push: comment_block_body
    - match: '-}'
      scope: punctuation.definition.comment
      pop: true

  ### Module header ##

  module_header:
    - match: ^(\s*)(module)\b
      captures:
        2: keyword.declaration.namespace.haskell
      push: module_header_line

  module_header_line:
    - meta_scope: meta.declaration.module.haskell
    - match: '({{upper_ident}}\.)*({{upper_ident}})'
      scope: entity.name.namespace.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: module_header_exports_list
    - match: \b(where)\b
      scope: keyword.control.context.haskell
      pop: true

  module_header_exports_list:
    - meta_scope: meta.declaration.exports.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: \b(type) (\({{operator}}\))
      captures:
        1: keyword.other.export.haskell
        2: keyword.operator.type.haskell
    - match: \b(pattern) ({{upper_ident}})
      captures:
        1: keyword.other.export.haskell
        2: variable.function.pattern.haskell
    - # explicitly check for `(..)`
      match: |-
        (?x)
          (\()
          (\.\.)
          (\))
      scope: meta.export.type_members.haskell
      captures:
        1: punctuation.section.parens.begin.haskell
        2: keyword.other.wildcard.export.haskell
        3: punctuation.section.parens.end.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: import_list_type_members
    - match: '{{upper_ident}}'
      scope: storage.type.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell

  ### Imports ###

  import:
    - match: ^(\s*)(import)\b
      captures:
        2: keyword.control.import.haskell
      push: import_line

  import_line:
    - meta_scope: meta.import.haskell
    - include: pop_when_deindent
    - match: \b(qualified|as|hiding)\b
      scope: keyword.control.import.modifiers.haskell
    - include: module_name
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: import_list

  # import UnliftIO (UnliftIO, withRunInIO)
  #                  ^^^^^^^^^^^^^^^^^^^^^
  import_list:
    - meta_scope: meta.declaration.imports.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: \b(type) (\({{operator}}\))
      captures:
        1: keyword.other.import.haskell
        2: keyword.operator.type.haskell
    - match: \b(pattern) ({{upper_ident}})
      captures:
        1: keyword.other.import.haskell
        2: variable.function.pattern.haskell
    - # explicitly check for `(..)`
      match: |-
        (?x)
          (\()
          (\.\.)
          (\))
      scope: meta.import.type_members.haskell
      captures:
        1: punctuation.section.parens.begin.haskell
        2: keyword.other.wildcard.import.haskell
        3: punctuation.section.parens.end.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell
    - match: \(
      scope: punctuation.section.parens.begin.haskell
      push: import_list_type_members
    - match: '{{upper_ident}}'
      scope: storage.type.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell

  # import GHC.Exts (IsList (Item, fromList))
  #                          ^^^^^^^^^^^^^^
  import_list_type_members:
    - meta_scope: meta.import.type_members.haskell
    - match: \)
      scope: punctuation.section.parens.end.haskell
      pop: true
    - match: '{{upper_ident}}'
      scope: variable.function.constructor.haskell
    - match: '{{lower_ident}}'
      scope: variable.function.haskell
    - match: ','
      scope: punctuation.separator.haskell
    - match: \({{operator_con}}\)
      scope: keyword.operator.constructor.haskell
    - match: \({{operator}}\)
      scope: keyword.operator.haskell #variable.other.import.operator.haskell

  ### Functions ###

  function:
    - match: '^(\s*)({{lower_ident}})'
      captures:
        2: entity.name.function.haskell
      branch_point: function
      branch:
        # try signature first, since it's easier to check if it fails
        # (nothing can go between the identifier and the '::')
        - function_signature
        - function_definition

  function_definition:
    - meta_content_scope: |-
        meta.function.parameters.haskell
        meta.pattern.haskell
    - include: pop_when_deindent
    - match: '='
      scope: keyword.other.function.definition.haskell
      set: function_definition_body
    - include: pattern_match

  function_definition_body:
    - include: pop_when_deindent
    # TODO

  function_signature:
    - match: '\s(::)\s'
      captures:
        1: keyword.other.function.signature.haskell
      set: function_signature_type
    - include: pop_when_deindent
    - match: '\S'
      fail: function

  function_signature_type:
    - include: pop_when_deindent
    # TODO

  ### Expressions ###

  expression:
    - match: '{{lower_ident}}'
      scope: variable.other.haskell
    - match: '{{upper_ident}}'
      scope: variable.other.type.haskell
    - match: '"'
      push: expression_string_body

  expression_string_body:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.haskell
    - match: '"'
      pop: true

  ### Pattern matching ###

  pattern_match:
    - match: '\b_\b'
      scope: keyword.other.wildcard.haskell
    - match: '{{lower_ident}}'
      scope: variable.other.haskell
    - match: '{{upper_ident}}'
      scope: variable.other.type.haskell
    - match: '@'
      scope: keyword.other.as_pattern.haskell
    - match: '\('
      scope: punctuation.section.parens.begin.haskell
    - match: '\)'
      scope: punctuation.section.parens.end.haskell
    - match: '\{'
      scope: punctuation.section.braces.begin.haskell
      push: pattern_match_record
    - match: '{{operator_con}}'
      scope: keyword.operator.constructor.haskell

  pattern_match_record:
    - meta_scope: meta.pattern.record.haskell
    - match: '\}'
      scope: punctuation.section.braces.end.haskell
      pop: true
    - # Person{boss = Just _, ..} (RecordWildCards)
      #                       ^^
      match: \.\.
      scope: keyword.other.wildcard.record.haskell
    - match: ','
      scope: punctuation.separator.haskell
    - # Person{boss = Just Person{name = name}}
      #        ^^^^^^
      match: '({{lower_ident}})\s*(=)'
      captures:
        1: variable.other.member.haskell
        2: keyword.operator.haskell
      push: pattern_match_record_nested
    - # Person{boss} (NamedFieldPuns)
      #        ^^^^
      match: '{{lower_ident}}'
      scope: variable.other.haskell

  # Person{boss = Just Person{name = name}}
  #               ^^^^^^^^^^^^^^^^^^^^^^^^
  pattern_match_record_nested:
    - match: '(?=[,}])'
      pop: true
    - include: pattern_match
